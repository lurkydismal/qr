# Tree hygiene

## tl;dr

* Regressions should be reverted first and questions asked later. Bringing the tree to green is higher priority.
* A breaking change is one that breaks the tests, and those need a migration guide.
* Expect that a new patch will be reviewed within two weeks, unless it is fixing a P0 bug in which case it should be reviewed the same day. Remember that reviewers are human beings with additional professional and personal responsibilities.

## Introduction

This page covers how to land a PR and other aspects of writing code for
qr other than the actual writing of the code. For guidance on
designing APIs, documenting, and formatting your code, see the
[Style guide for qr repo](Style_Guide.md) document.

## Overview

The general process for submitting code to a qr repository is as follows:

1. Fork the repository on GitHub.

1. If there is not already an issue covering the work you are interested in doing,
    then file a new bug to describe the issue you are addressing. Having an issue means
    that if we have to revert the PR, we can reopen the issue and not lose track of the
    fact that the work didn't fully land. Similarly if someone works on a PR then stops
    before it can land, having an issue means we have somewhere to point to the code when
    we close the PR without landing it, so other people can take it over.

1. Discuss your design on the issue. See [Design Documents](Design_Documents.md) for advice.
    The more buy-in you get from the rest of the team (especially the relevant leads),
    the easier the rest of the process will be.
    You can put the label "proposal" on your issue to indicate that you have a design
    up for discussion in the issue.

1. If the work you are doing affects our privacy surface, such as modifying how
    we collect analytics, crash logs, or the like, then please reach out to @lurkydismal
    to discuss your changes (you'll want to solicit feedback,
    use the [template](Template.md).

1. Create a branch off of `main` (or if the repository has not yet switched to
    having a `main` branch, from `main`) on your GitHub fork of the repository, and implement
    your change. Make sure it is tested (see the next section for details).

    You must follow the guidelines described in the [Style guide for qr repo](Style_Guide.md).
    Files must not have trailing spaces.
    For the server, C, C++ code should be formatted with
    `clang-format` before submission (use `clang-format
    --style=file -i`).

    Unfortunately we have been advised that we cannot currently accept code or other content that was
    written by tools such as ChatGPT, GitHub Co-pilot, Grammarly, or Bard.

1. Submit this branch as a PR to the relevant qr repository.

1. Get your code reviewed (see below). You should probably reach out to the relevant
    expert(s) for the areas you touched and ask them to review your PR directly.
    GitHub sometimes recommends specific reviewers; if you're not sure who to ask,
    that's probably a good place to start.

1. Make sure your PR passes all the pre-commit tests. Consider running some of the
    post-commit tests locally If any tests break, please
    see the breaking change policy section below for details on how to proceed.

    **If the trees are showing any regressions, only fixes
    that improve the situation are allowed to go in.**

1. Watch the post-commit tests to make sure everything passes. If anything
    goes wrong, revert your patch and study the problem. You should aim to be the one to revert your patch. You will be racing everyone
    else on the team who will also be trying to revert your patch.

<!-- _See also: [[What should I work on?]]_ -->

## Tests

Every change must be tested, except for PRs that:

* only remove code (no modified or added lines) to remove a feature or remove dead code. (Removing code to fix a bug still needs a test.)
* only affect comments (including documentation).
* only affect code inside the `.github` directory config files.
* only affect `.md` files.
* are generated by automated bots.

**If the PR is in a repository that is not listed above, meaning is the responsibility of the pull request reviewer to make sure that tests have been added to support the code change.**

If a reviewer says a PR should have a test, then it needs a test regardless of the exemptions above.

## Using git

Follow these steps to start working on a patch:

* `git fetch upstream`
* `git checkout upstream/main -b name_of_your_branch`
* Hack away.
* `git commit -a -m "<your informative commit message>"`
* `git push origin name_of_your_branch`

GitHub provides you with a link for submitting the pull request in the message output by `git push`.

Because `git pull` will often miss tags that are used to define the release, it is recommended to use `git fetch` typically to avoid version mismatches.

Use `git fetch upstream; git rebase upstream/main; git push origin your_branch_name` to update your PRs, rather than using merge.

Please make sure all your patches have detailed commit messages explaining what the problem was and
what the solution is.

## Getting a code review

Every PR must be code-reviewed before check-in, including things like
rolling a dependency. Getting a review means that a regular qr
contributor (someone with commit access) has "approved" the PR in the
GitHub UI. We call this "getting an LGTM" ("looks good to me").

If you are not yourself someone with commit access, then a second person
with commit access must also review and approve your PR. This ensures that
two people with commit access (trusted contributors) agree on every commit.

### Why

Code review serves many critical purposes. There's the obvious
purpose: catching errors. Even the most experienced engineers
frequently make errors that are caught by code review. But there are
also many other benefits of code reviews:

* It spreads knowledge among the team. Since every line of code will
  have been read by two people, it's more likely that once you move
  on, someone else will understand the code.

* It keeps you honest. Knowing that someone will be reading your
  code, you are less tempted to cut corners and more motivated to
  write code you are proud of.

* It exposes you to different modes of thinking. Your code reviewer
  has probably not thought about the problem in the same way you
  have, and so may have a fresh perspective and may find you a better
  way to solve the problem.

### When

If you're working on a big patch, don't hesitate to get reviews early,
before you're ready to check code in. Also, don't hesitate to ask for
multiple people to review your code, and don't hesitate to provide unsolicited
comments on other people's PRs (although approvals in the GitHub UI
should be reserved for those with contributor access). The more
reviews the better.

### Who

Code should be reviewed by the owner (tech lead) of the area(s) of the codebase that you are changing,
or someone to whom they have delegated that authority.

If anyone else leaves comments, please also wait for their approval (LGTM) before landing code.

### How

Code review status is managed via GitHub's approval system. PRs should
not be merged unless one or more contributors with commit access (at
least one of which should be very familiar with the code in question)
have approved the PR in the GitHub UI.

Reviewers should carefully read the code and make sure they understand
it. A reviewer should check the code for both high level concerns,
such as whether the approach is reasonable and whether the code's structure makes sense, as well as
lower-level issues like how readable the code is and adherence to the
[qr style guide](Style_Guide.md).
Use [these best practices](https://mtlynch.io/human-code-reviews-1/)
when reviewing code and providing comments.

As a reviewer, you are the last line of defense.

1. Take a step back. What problem is the PR trying to solve? Is it a real problem?
1. What other solutions could we consider? What could we do to make this even better?
1. Is it the best API? See our [philosophy](Style_Guide.md#philosophy) section. Look for state duplication, synchronous slow work, complecting, global state,
overly-specific APIs, API cliffs and API oceans. If these terms
don't make sense, read the style guide again.
1. Is it the best implementation? Again, see our [style guide](Style_Guide.md#coding-patterns-and-catching-bugs-early), in particular its section on good coding patterns. Are there hacks? Are we taking on more technical debt? Think of ways in which the code could break.
1. Is it testable? Is it tested? **All code must be tested.** Are there asserts? Encourage liberal use of assertions.
1. Look for mistakes in indenting the code and other trivial formatting problems.
1. Is new code licensed correctly?
1. Is the documentation thorough and useful? Look for useless documentation, empty prose, and breadcrumbs. See the [documentation section](Style_Guide.md#documentation) of our style guide for what that means.
1. Check for good grammar in API docs and comments. Check that identifiers are named according to our conventions.

Once you are satisfied with the contribution, and _only_ once you are satisfied,
use the GitHub "Approval" mechanism (an "LGTM" comment is not sufficient).
If you feel like you are being worn down, hand the review to someone else. Consider
our [conflict resolution](CODE_OF_CONDUCT.md#conflict-resolution)
policy if you feel like you are being forced to agree to something you don't like.

Reviewers should not give an LGTM unless the patch has tests that verify
all the affected code, or unless a test would make no sense. If you
review a patch, you are sharing the responsibility for the patch with
its author. You should only give an LGTM if you would feel confident
answering questions about the code.

In general, reviewers should favor approving a PR once it is in a state where it definitely improves the overall code health of the system being worked on, even if the PR isn't perfect.

Reviewers should always feel free to leave comments expressing that something could be better, but if it's not very important, prefix it with something like "Shouldn't block this PR but: " to let the author know that it's just a point of polish that they could choose to ignore in the current PR (these should be documented in TODO comments with a tracking issue).

If you are not a regular qr contributor (someone with commit access),
we very much welcome your reviews on code contributions in the form of comments
on the code, but please refrain from approving or LGTM'ing changes, as it
confuses PR authors, who may think your approval is authoritative and merge
the PR prematurely.

When commenting on a PR, keep in mind the following mantra:

* Be polite and grateful. Graceful professionalism.
* Explain what is happening. Explain why it is happening.
* Provide next steps. Set expectations.

It's better to close a PR than to leave it in limbo.

### What (to do when the patch is abandoned)

Sometimes the contributor is unable to finish the work of landing the patch. In that case, if the PR has promise, we may close it but mention it on the relevant issue so that other interested parties can pick it up. Such issues are given the label [`has partial patch`](https://github.com/lurkydismal/qr/labels/has%20partial%20patch).

## Landing a patch

Once you have submitted your patch and received your LGTM, if you do not have commit access to
the repository yet, then wait for one of the project maintainers to submit it for you.

### Squashing commits

When you squash commits, by default, GitHub will concatenate all your commit messages to form a unified commit message.  This often yields an overly verbose commit message with many unhelpful entries (e.g. "fix typo").  Please double-check (and hand-edit if necessary) your commit message before merging such that the message contains a helpful description of the overall change.

## Regressions in functionality

If a check-in has caused a regression on main, revert (roll back) the
check-in (even if it isn't yours). When main is broken, it slows down
everyone else on the project, so we want to get the tree green again as soon
as possible.

If your revert is a straight revert of the latest commit, then you do not need to wait for precommit tests before landing it (since by definition
you are bringing the tree back to a known configuration). Just create the revert and land it, then tell the person
whose patch you reverted that you reverted their patch, and leave a comment
on the PR that you reverted.

There is no shame in making mistakes.

If the regression still left the tree in a green state (meaning that
the failure is one we were not previously testing for), please write a test for
this failure mode!

## Avoid "Revert "Revert "Revert "Revert "Fix foo"""" commit messages

Please limit yourself to one "Revert" (or "reland" or similar) per commit message, otherwise we won't have any idea what is actually landing. Is it putting us back to where we were before?
Is it adding new code? Is it a controversial new feature that actually caused
a regression before but is now fixed (we hope)?

Only use "Revert" if you are actually returning us to a known-good state.
When you later revert the revert, just land the PR afresh with the original commit message,
possibly updated with the information since collected (and ideally, including a link
to the original PR and to the revert PR so that people can follow the breadcrumbs later).

## Landing Revert Changes

Reverts are typically made when something is broken and the tree has closed. This means that
we have an urgent situation and would like to remove the troublesome code as soon as possible.
The following process can be used to revert code:

1. Navigate to the closed pull request that contains the changes we need to revert and click
the revert button.
![image](markdown_assets/revert.jpg)
1. In the next screen you can feel free to add context to the new pull request then click the
button to open the pull request.
1. Assign the follow up review to a team member to review the reverted code.
1. Once the code has been reviewed the assignee can go ahead and close the issue. Be sure to
link any useful documents that help to explain what went wrong with the original feature to
the follow up review issue.

## Handling breaking changes

We want our APIs to be intuitive; if being backwards-compatible requires making
an API into something that we would never have designed that way unless forced
to by circumstances, then we should instead break the API and make it good.

The process for making breaking changes is as follows:

### 1. Determine if your change is a breaking change

The first step in making a breaking change is to implement the change you wish to see and run the existing tests against your new code (without having changed the tests first). Changes that break (i.e. require changes to) one or more of the tests are considered "breaking changes".

This definitions is binding. If you think you need an exemption to this policy, please contact @lurkydismal. If a breaking change lands without following this policy and without an explicit exemption from @lurkydismal, it must be reverted.

### 2. Evaluate the breaking change proposal

If you discover that your change would be a breaking change as defined above, we must carefully evaluate it. Create a design document ([use this template](Template.md)). You want to describe the change in detail, and ask for feedback. Things you should include are:

* What problem are you solving?
* What does migrating code to your proposed new API look like? Show several before and after examples.
* What other alternatives did you consider?
* A request for feedback. Is the change valuable?

Consider if you really need to make this change. In general, merely renaming a class to make things slightly clearer is insufficient value to justify a breaking change. Such changes leave behind a legacy of old tutorials, YouTube videos, StackOverflow comments, etc, that reference the old name, and so any improvement to the developer experience can be easily offset by the added burden on our ecosystem as a whole.

### 3. Prepare your change

Rather than deploying the proposed change as one PR that immediately breaks existing code, adjust your PR so that it introduces the new functionality, API, behavior change, etc, in an opt-in fashion.

_For example, rather than replacing a callback with another, introduce the new callback and discourage use of the old one. Rather than changing the order in which a certain argument is processed, provide a flag that selects which order the arguments will be processed in._

When changing the semantics of an API with a temporary opt-in, a three-phase change is needed (adding the new API and opt-in, then removing the old API, then removing the opt-in.)

If possible, avoid four-phase deprecations (adding a new API with a temporary name and deprecating an old API, removing the old API, changing the new API to the old name and deprecating the temporary name, and finally removing the temporary name), because they involve a lot of churn and will irritate our developers.

Stage your change and the documentation for your change. Typically this will be two or more PRs, plus PRs to fix the tests that were broken (see step 1), as well as writing a migration guide as a PR to the repository.

Use our [breaking change migration guide template](Breaking_Changes_Template.md) (follow all the instructions in the comments) to create the migration guide that describes the change. Do not land the migration guide at this time. You will need to update it before you land it in the last step.

### 4. Land your change

Once you are ready, have received feedback, iterated on your design and your migration guide, land your initial change and start migrating clients. _Do not yet land the migration guide._ Once all the clients are migrated, land your final change. (You may have several iterations here if you have a multiphase roll-out.)

### 5. Document the change, including clear documentation for migrating code, with samples, and clear rationales for each change

Once everything has landed:

* update your migration guide based on your experience migrating everyone,
* update the timeline on the guide,

### Deprecations

Old APIs can be marked as deprecated as part of this process. Deprecation is not a way to avoid making a breaking change; you should consider deprecating an API to be equivalent to removing it, as we ourselves consider using a deprecated API to be anathema (triggering a build failure).

The syntax for deprecations must match the following pattern:

```c++
\deprecated Call prepareFrame followed by owner.requestVisualUpdate() instead.
  This will enable an improvement to performance in a future version of qr.
  This feature was deprecated after v2.9.0-0.1.pre .
__attribute__( ( deprecated ) )
```

In other words:

```c++
\deprecated [description of how to migrate]
  [brief motivation for why we are breaking the API]
  This feature was deprecated after [beta version at time of deprecation].
__attribute__( ( deprecated ) )
```

Using this standard form ensures that we can write a script to detect all deprecated APIs and remove them.

Deprecations are removed in a consistent "first-in-first-out" fashion. Where possible, write appropriate migrations guides.
